import tkinter as tk
from tkinter import filedialog, messagebox
from PIL import Image, ImageTk
from ultralytics import YOLO
import os
import glob

# Load YOLO Model
model = YOLO(r'D:\1 FOLDER\DIT\WS 24\Case study\YOLO\yolo-20250122T225741Z-001\yolo\runs\detect\train7\weights\best.pt')  # Update with your trained model path


# Function to find the latest prediction directory
def get_latest_prediction_dir():
    # Locate all prediction directories
    prediction_dirs = glob.glob("runs/detect/predict*")
    if not prediction_dirs:
        raise FileNotFoundError("No prediction directories found.")
    # Sort by modified time and get the latest
    return max(prediction_dirs, key=os.path.getmtime)


# Function to Run YOLO and Show Results
def process_image():
    # Disable the button while processing
    btn.config(state="disabled")

    # Ask user to select an image file
    file_path = filedialog.askopenfilename(filetypes=[("Image Files", "*.jpg;*.jpeg;*.png")])
    if not file_path:
        btn.config(state="normal")  # Re-enable the button if no file is selected
        return  # If no file selected, exit

    # Perform Prediction
    try:
        # Run prediction and save results
        input_file_name = os.path.basename(file_path)
        results = model.predict(source=file_path, save=True)  # YOLO saves output to 'runs/detect/predict*'

        # Prepare text for detection details
        details_text = ""
        final_prediction = "Healthy"  # Default assumption is healthy
        is_defective = False  # Track if any defect is found

        # Dictionary to store the highest confidence for each class
        highest_confidences = {}

        # Process results
        for result in results:  # Iterate through results (one per image)
            # Get the detected class indices and confidence levels
            class_indices = result.boxes.cls.cpu().numpy().astype(int)  # Class indices
            confidences = result.boxes.conf.cpu().numpy()  # Confidence scores

            # Update the dictionary with the highest confidence for each class
            for cls, conf in zip(class_indices, confidences):
                if cls not in highest_confidences or conf > highest_confidences[cls]:
                    highest_confidences[cls] = conf

        # Map class indices to names and prepare text
        if hasattr(model, 'names'):
            for cls, conf in highest_confidences.items():
                class_name = model.names[cls]
                details_text += f"Class: {class_name}, Confidence: {conf:.2f}\n"
                if class_name.lower() == "defect":  # Check for defects
                    is_defective = True

        # Update final prediction
        if is_defective:
            final_prediction = "Defect"

        # Update GUI labels
        details_label.config(text=details_text)
        prediction_label.config(text=f"Final Prediction: {final_prediction}",
                                fg="red" if final_prediction == "Defect" else "green")

        # Find the most recent predict directory
        save_dir = get_latest_prediction_dir()

        # Find the output image path
        input_file_base = os.path.splitext(os.path.basename(file_path))[0]
        output_image_path = None
        for ext in ('.jpg', '.jpeg', '.png'):  # Check common output extensions
            potential_output_path = os.path.join(save_dir, input_file_base + ext)
            if os.path.exists(potential_output_path):
                output_image_path = potential_output_path
                break

        # Display the output image in the GUI
        if output_image_path and os.path.exists(output_image_path):
            show_image(output_image_path)
        else:
            messagebox.showerror("Error", "Processed image not found!")
            print("Error: Processed image not found!")

    except Exception as e:
        messagebox.showerror("Error", f"An error occurred: {str(e)}")
        print(f"An error occurred: {str(e)}")

    # Re-enable the button after processing
    btn.config(state="normal")


# Function to display image in the GUI
def show_image(image_path):
    # Check if the image path exists before trying to load
    if not os.path.exists(image_path):
        messagebox.showerror("Error", "Image path does not exist!")
        print("Error: Image path does not exist!")
        return

    # Clear the previous image from the panel to prevent overlap
    panel.configure(image=None)
    panel.image = None  # Reset the reference to the previous image

    # Open and resize the image for the GUI
    img = Image.open(image_path)
    img.thumbnail((400, 400))  # Resize for display purposes

    # Convert the image to PhotoImage for Tkinter
    img_tk = ImageTk.PhotoImage(img)
    panel.configure(image=img_tk)
    panel.image = img_tk  # Keep reference to avoid garbage collection


# Create Tkinter GUI
root = tk.Tk()
root.title("Defect Detection System")
screen_width = root.winfo_screenwidth()
screen_height = root.winfo_screenheight()

# Calculate 3/4 of the screen size
window_width = int(screen_width * 0.90)
window_height = int(screen_height * 0.90)

# Calculate the position to center the window
x_position = (screen_width - window_width) // 2
y_position = (screen_height - window_height) // 2
root.geometry(f"{window_width}x{window_height}+{x_position}+{y_position}")

# Set the background color
root.configure(bg="#f4f4f4")

# Heading Label
heading = tk.Label(root, text="Defect Detection System", font=("Helvetica", 24, "bold"), bg="#f4f4f4", fg="#333")
heading.pack(pady=20)

# Create a button to load the image with better styling
btn = tk.Button(root, text="Select Image and Detect", command=process_image, font=("Helvetica", 14, "bold"), bg="#4CAF50", fg="white", relief="raised", width=20, height=2)
btn.pack(pady=20)

# Create a panel to display the image
panel = tk.Label(root, bg="#f4f4f4")
panel.pack()

# Create a label to display detection details
details_label = tk.Label(root, text="", justify="left", fg="black", font=("Arial", 12), bg="#f4f4f4")
details_label.pack(pady=10)

# Create a label to display the final prediction
# Initially, hide the prediction text by setting it to an empty string
prediction_label = tk.Label(root, text="", font=("Arial", 20, "bold"), bg="#f4f4f4")
prediction_label.pack(pady=10)

# Start the GUI loop
root.mainloop()
